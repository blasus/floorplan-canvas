import * as paperCore from "paper/dist/paper-core";
import { Point, Tool } from "paper/dist/paper-core";
import * as Cycle from "cycle";

import {
  isHandler,
  ManagerOptions,
  ManagerOutlineEventHandlers,
  ManagerOutlineEventKeys,
  OutlineConstructorOptions,
  OutlineData,
  OutlineEventPayload,
  SVGSource,
  SvgSizing,
  OutlineOptions,
} from "./types";
import { 
  DEFAULT_MAX_ZOOM,
  DEFAULT_MIN_ZOOM,
  DEFAULT_NUMBER_CELL,
  ZOOM_RATIO
} from "./constants";
import { AutoAlign } from "./aligner";
import { Grid } from "./grid";
import { LayerController } from "./layers/layerController";
import { Outline } from "./outline";
import { SVGUploader } from "./svg-uploader";
import { UndoManager } from "./undo-redo";
import { iconPen } from './icons/icon.model';

export class Manager {
  private _canvas: HTMLCanvasElement;
  private _layerController: LayerController;
  private _svgUploader: SVGUploader;
  private _showGrid: boolean = false;
  private _grid: Grid;
  // constants for zoom in/out feature
  private _disableSvgAutoResize: boolean = false;
  private _maxZoom: number = DEFAULT_MAX_ZOOM;
  private _minZoom: number = DEFAULT_MIN_ZOOM;
  private _zoomStep: number = ZOOM_RATIO;
  // this flag checks whether pan gesture is enabled. Default to false
  private _isPanEnabled: boolean = false;
  private _undoLimit: number;
  private _cellSize: number;
  // collection of the outlines
  private outlines: { [name: string]: Outline } = {};
  private currentOutline: Outline;
  private Scope: paper.PaperScope = {} as paper.PaperScope;
  private autoAligner: AutoAlign;

  constructor(canvas: HTMLCanvasElement, opts?: ManagerOptions) {
    this._canvas = canvas;

    if (opts) {
      const {
        showGrid,
        maxZoom,
        minZoom,
        zoomStep,
        undoLimit,
        disableSvgAutoResize,
      } = opts;

      this._showGrid = showGrid;
      this._maxZoom = maxZoom || DEFAULT_MAX_ZOOM;
      this._minZoom = minZoom || DEFAULT_MIN_ZOOM;
      this._zoomStep = zoomStep || ZOOM_RATIO;
      this._disableSvgAutoResize = disableSvgAutoResize;
      this._undoLimit = undoLimit;
    }

    if (this._undoLimit) {
      UndoManager.getInstance().limit = this._undoLimit;
    }

    this.init();
  }

  private init(): void {
    paperCore.install(this.Scope);
    paperCore.setup(this._canvas);
    this._layerController = LayerController.getInstance();
    this._layerController.setProject(this.Scope.project);

    this.addEventListeners();
    this.renderAdditionalOptions();
    this.autoAligner = new AutoAlign([]);
  }

  public destroy(): void {
    // For some reason ts doesn't see this method (remember that the types are
    // autogenerated), nor it's documented. @see
    // `https://github.com/paperjs/paper.js/blob/develop/src/core/PaperScope.js`
    // @ts-ignore
    paperCore.remove();
  }
  /**
   * Exports the canvas as json.
   * @returns the canvas as json array of outlines.
   */
  public exportAsJson(): object {
    const json: object[] = this.Scope.project.exportJSON({
      asString: false,
    }) as any;
    json.shift();
    json.shift();

    return json;
  }

  /**
   * Exports the canvas as json string.
   * @returns the string representing the json of the canvas.
   */
  public exportAsString(): string {
    const json = this.exportAsJson();

    // Stringify the json generated from paper
    // will throw the error TypeError: cyclic object value.
    // Delete cyclic object values using cycle.js:
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Cyclic_object_value
    return JSON.stringify(Cycle.decycle(json));
  }

  private addEventListeners(): void {
    // Remember, that if the event's handler functions are not bound to any
    // particular context, `this` would be bound to the instance (i.e.
    // `Scope.view` or `Scope.tool`) that is listened.
    const manager = this;

    // Paper `view` or `tool` events are global, so we call the necessary
    // handlers manually for the elements we need.
    // This way, the events handling logic can be isolated to separate classes,
    // for example `Outline`.
    this.Scope.view.on({
      mousedown: function(event) {
        if (!manager._isPanEnabled) {
          manager.currentOutline?.handleViewEvent("mousedown", event);
        } else {
          manager._canvas.style.cursor = "grabbing";
        }
      },
      mousedrag: function(event) {
        if (!manager._isPanEnabled) {
          manager.currentOutline?.handleViewEvent("mousedrag", event);
        }
      },
      mousemove: function(event) {
        if (!manager._isPanEnabled) {
          manager.currentOutline?.handleViewEvent("mousemove", event);
        }
      },
      mouseup: function(event) {
        if (!manager._isPanEnabled) {
          manager.currentOutline?.handleViewEvent("mouseup", event);
        } else {
          manager.setCanvasCursor();
        }
      },
      mouseleave: function(event) {
        if (!manager._isPanEnabled) {
          manager.currentOutline?.handleViewEvent("mouseleave", event);
        }
      },
      mouseenter: function(event) {
        if (!manager._isPanEnabled) {
          manager.currentOutline?.handleViewEvent("mouseenter", event);
        }
      },
      resize: function(event) {
        // Whenever the view is resized, move the elements to the center:
        if (manager._showGrid) {
          manager._grid?.redraw(manager.cellSize);
        }
        // resize the rendered svg.
        if (!manager._disableSvgAutoResize) {
          manager._svgUploader?.fitIntoViewSVG();
        }

        // then re-enable the very top layer in order to continue with the drawing.
        manager._layerController.activateTopLayer();
      },
    });
  }

  private renderAdditionalOptions(): void {
    // set the changes to the cursor.
    this.setCanvasCursor();

    // render the grid
    if (this._showGrid) {
      this.drawGrid();
    }

    this.setPanConfiguration();
  }

  /**
   * Sets up the configuration for the pan gesture mode.
   */
  private setPanConfiguration(): void {
    // create the tool to enable panning
    const toolPan = new Tool();
    const view = this.Scope.view;
    toolPan.onMouseDrag = (e: paper.ToolEvent) => {
      // prevent dragging the view if zoom is in default state.
      if (this._isPanEnabled && view.zoom > this._minZoom) {
        view.center = e.downPoint.subtract(e.point).add(view.center);
        // If user pans slightly out of the initial view box, there will be no
        // grid, so redraw it.
        this._grid?.redraw(this._cellSize);
      }
    };
    // reset the view to the center on double click
    view.onDoubleClick = (e: MouseEvent) => {
      this.resetPan();
    };
  }

  private resetPan(): void {
    const canvas = this._canvas;
    const cWidth = canvas.scrollWidth;
    const cHeight = canvas.scrollHeight;
    this.Scope.view.center = new Point(cWidth / 2, cHeight / 2);
  }

  private setCanvasCursor(): void {
    const url = `data:image/svg+xml;utf8,${encodeURIComponent(iconPen.data)}`;
    const value = this._isPanEnabled ? "grab" : `url(${url}), auto`;
    this._canvas.style.cursor = value;
  }

  /**
   * Draws the grid ruler.
   * @param cellSize optional number to set cell size
   */
  public drawGrid(cellSize?: number): void {
    if (this._grid) {
      this._grid.destroy();
    }

    if (cellSize) {
      this._cellSize = cellSize;
    }

    this._grid = new Grid({
      view: this.Scope.view,
      cellSize: this.cellSize,
      layer: this._layerController.getLayerAtIndex(0),
    });

    this._showGrid = true;
    this._layerController.activateTopLayer();
  }

  /**
   * Uploads a new svg file to the canvas.
   * @param src a url string of the image or the svg itself.
   * @param onLoad optional callback for onload event.
   */
  public loadSVG({
    src,
    onLoad,
    options,
  }: {
    src?: SVGSource;
    onLoad?: Function;
    options?: SvgSizing;
  }): void {
    if (!this._svgUploader) {
      this._svgUploader = new SVGUploader({
        src,
        project: this.Scope.project,
        canvas: this._canvas,
        onLoad,
        layer: this._layerController.getLayerAtIndex(1),
      });
    } else if (src) {
      this._svgUploader.src = src;
    }

    this._svgUploader.loadSVG(options);
  }

  public removeSvg() {
    if (this._svgUploader) {
      this._svgUploader.remove();
    }
  }

  public getSvgSizing = (): SvgSizing | undefined => {
    if (!this._svgUploader) {
      return
    }
    
    const {
      width,
      height,
      topLeft: { x, y },
    } = this._svgUploader.getSvgBounds();

    return {
      width,
      height,
      topLeft: { x, y },
    };
  };

  public undo(): void {
    const undoManager = UndoManager.getInstance();
    if (undoManager.hasUndo()) {
      undoManager.undo();
    }
  }

  public redo(): void {
    const undoManager = UndoManager.getInstance();
    if (undoManager.hasRedo()) {
      undoManager.redo();
    }
  }

  public centerTo(position: [x:number, y: number]) {
    this.Scope.view.center = new Point(position);
    this._grid?.redraw(this._cellSize);
  }

  /**
   * Zoom the view by the passed scale factor.
   * @param scale
   */
  public zoom(scale: number): void {
    if (scale < this._minZoom || scale > this._maxZoom) return;

    this.Scope.view.zoom = scale;
    // Zooming may find no grid.
    this._grid?.redraw(this._cellSize);
  }

  /**
   * Zoom in by a fixed quantity, if possible.
   */
  public zoomIn(): void {
    const zoom = this.Scope.view.zoom;
    this.zoom(zoom + this._zoomStep);
  }

  /**
   * Zoom out by a fixed quantity, if possible.
   */
  public zoomOut(): void {
    const zoom = this.Scope.view.zoom;
    this.zoom(zoom - this._zoomStep);
  }

  /**
   * Reset the zoom to its default state.
   */
  public resetZoom(): void {
    this.zoom(1);
    // we need at this point to reset the view in case
    // the user played with pan gesture before resetting the
    // zoom.
    this.resetPan();
  }

  /**
   * Enables/disables the pan gesture mode.
   */
  public togglePanMode(): void {
    this._isPanEnabled = !this._isPanEnabled;
    this.setCanvasCursor();
  }

  public get isPanModeEnabled(): boolean {
    return this._isPanEnabled;
  }

  private get cellSize(): number {
    if (this._cellSize) {
      return this._cellSize;
    }

    return this._canvas.scrollWidth / DEFAULT_NUMBER_CELL;
  }

  public getOutlineData = (name: string): OutlineData => {
    return this.outlines[name]?.getData();
  };

  public getAllOutlinesData = (): { [name: string]: OutlineData } => {
    const outlineData = {};

    Object.entries(this.outlines).forEach(([name, outline]) => {
      outlineData[name] = outline.getData();
    }, {});

    return outlineData;
  };

  public onOutline?: ManagerOutlineEventHandlers = {};

  public addOutline({
    name,
    segments,
    closed,
    options,
  }: Partial<OutlineConstructorOptions>) {
    const layer = this._layerController.addLayer();
    const aligner = this.autoAligner;
    const outline = new Outline({
      name,
      segments,
      closed,
      options,
      layer,
      events: {
        "*": (event, payload) => { 
          this.dispatchOutlineEvents(event, payload); 
          this.updateAutoalignReferencePoints(); 
        },
       },
      aligner
    });
    this.outlines[name] = outline;

    if (this.currentOutline) {
      this.currentOutline.deactivate();
    }

    outline.activate();
    this.currentOutline = outline;

    this.dispatchOutlineEvents("add", { path: outline.getData() });
    this.updateAutoalignReferencePoints();

    return outline;
  }

  public closeCurrentOutline = () => {
    this.currentOutline?.closePathWithUndo();
  };

  public removeOutline(name: string) {
    const outline = this.outlines[name];

    if (outline) {
      const outlineData = outline.getData();
      this._layerController.removeLayer(outline.layer);
      outline.destroy();
      delete this.outlines[name];

      if (this.currentOutline.name === outline.name) {
        this.currentOutline = undefined;
      }

      this.dispatchOutlineEvents("delete", { path: outlineData });
      this.updateAutoalignReferencePoints();
    }
  }

  public setOutlineStyles = (name: string, styles: OutlineOptions) => {
    const outline = this.outlines[name]
    
    if (outline) {

    outline.setOptions(styles)
  }
  }

  public resetOutlineStyles = (name: string) => {
    const outline = this.outlines[name]
    
    if ( outline) {
      outline.resetOptions()
    }
  }

  public activateCurrentOutline = () => {
    this.currentOutline?.activate();
  };

  public deactivateCurrentOutline = () => {
    this.currentOutline?.deactivate();
  };

  private updateAutoalignReferencePoints = () => {
    // Get a single list of all the points of all the Outlines.
    const points: paper.Point[] = Object.values(this.outlines)
      .map((outline) => outline.getPathPoints())
      .flat();

    this.autoAligner.setReferencePoints(points);
  };

  private dispatchOutlineEvents = (
    eventType: ManagerOutlineEventKeys,
    payload: OutlineEventPayload
  ) => {
    const handler: ManagerOutlineEventHandlers[ManagerOutlineEventKeys] =
      this.onOutline[eventType];

    if (handler) {
      if (isHandler(handler)) {
        handler(payload);
      } else {
        handler("*", payload);
      }
    }
  };
}
